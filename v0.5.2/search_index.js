var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Quick-Start-1","page":"API","title":"Quick Start","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The easiest way to work with Meshing is with GeometryTypes. This package extends the mesh constructors from GeometryTypes.jl for convience.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The algorithms operate on a Function, AbstractArray, or SignedDistanceField and output a concrete AbstractMesh. For example, we can use the GeometryTypes API as follows:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using Meshing\nusing GeometryTypes\nusing LinearAlgebra: dot, norm\nusing FileIO\n\n# Mesh an equation of sphere in the Axis-Aligned Bounding box starting\n# at -1,-1,-1 and widths of 2,2,2 using Marching Cubes\nm = GLNormalMesh(HyperRectangle(Vec(-1,-1,-1.), Vec(2,2,2.)), MarchingCubes()) do v\n    sqrt(sum(dot(v,v))) - 1\nend\n\n# save the Sphere as a PLY file\nsave(\"sphere.ply\",m)","category":"page"},{"location":"api/#","page":"API","title":"API","text":"For a full listing of concrete AbstractMesh types see GeometryTypes.jl mesh documentation.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Alternatively, we can use the isosurface API to sample a function:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using Meshing\nusing LinearAlgebra\nusing StaticArrays\n\nm = isosurface(origin=SVector(-1,-1,-1.), widths = SVector(2,2,2.), samples = (40,40,40)) do v\n    sqrt(sum(dot(v,v))) - 1\nend\n\n# by default MarchingCubes() is used, but we may specify a different algorithm as follows\n\npoints, faces = isosurface(MarchingTetrahedra(), origin=SVector(-1,-1,-1.), widths = SVector(2,2,2.), samples = (40,40,40)) do v\n    sqrt(sum(dot(v,v))) - 1\nend","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Similarly if we have some 3D levelset data such as a CT scan, we can just do:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using Meshing\n\nA = rand(50,50,50)\n\npoints,faces = isosurface(A)","category":"page"},{"location":"api/#Meshing-Algorithms-1","page":"API","title":"Meshing Algorithms","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Three meshing algorithms exist:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"MarchingCubes()\nMarchingTetrahedra()\nNaiveSurfaceNets()","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Each takes optional iso, eps, and insidepositive parameters, e.g. MarchingCubes(iso=0.0,eps=1e-6,insidepositive=false).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Here iso controls the offset for the boundary detection. By default this is set to 0. eps is the detection tolerance for a voxel edge intersection. insidepositive sets the sign convention for inside/outside the surface (default: false).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Users must construct an algorithm type and use it as an argument to a GeometryTypes mesh call or isosurface call.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Below is a comparison of the algorithms:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Algorithm Type Face Type Unique Vertices Performance Interpolation\nNaive Surface Nets Quad Yes ~1x Voxel Edge Weight\nMarching Cubes Triangle No/Partial 1x Linear on Edge\nMarching Tetrahedra Triangle Yes 3x Linear on Edge","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Visual Comparison: From left: Marching Cubes, Naive Surface Nets, Marching Tetrahedra","category":"page"},{"location":"api/#","page":"API","title":"API","text":"(Image: comparison)","category":"page"},{"location":"api/#","page":"API","title":"API","text":"MarchingCubes\nMarchingTetrahedra\nNaiveSurfaceNets\nMeshing.AbstractMeshingAlgorithm","category":"page"},{"location":"api/#Meshing.MarchingCubes","page":"API","title":"Meshing.MarchingCubes","text":"MarchingCubes(iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)\nMarchingCubes(;iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)\nMarchingCubes(iso)\nMarchingCubes(iso,eps)\n\nSpecifies the use of the Marching Cubes algorithm for isosurface extraction. This algorithm provides a good balance between performance and vertex count. In contrast to the other algorithms, vertices may be repeated, so mesh size may be large and it will be difficult to extract topological/connectivity information.\n\niso (default: 0.0) specifies the iso level to use for surface extraction.\neps (default: 1e-3) is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts (default: true) if true will merge vertices within a voxel to reduce mesh size by around 30% and with slight performance improvement.\ninsidepositive (default: false) set true if the sign convention inside the surface is positive, common for NRRD and DICOM data\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.MarchingTetrahedra","page":"API","title":"Meshing.MarchingTetrahedra","text":"MarchingTetrahedra(iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)\nMarchingTetrahedra(;iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)\nMarchingTetrahedra(iso)\nMarchingTetrahedra(iso,eps)\n\nSpecifies the use of the Marching Tetrahedra algorithm for isosurface extraction. This algorithm has a roughly 2x performance penalty compared to Marching Cubes, and generates more faces. However, each vertex is guaranteed to not be repeated, making this algorithm useful for topological analysis.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts (default: true) if false, vertices will not be unique and have repeated face references.\ninsidepositive (default: false) set true if the sign convention inside the surface is positive, common for NRRD and DICOM data\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.NaiveSurfaceNets","page":"API","title":"Meshing.NaiveSurfaceNets","text":"NaiveSurfaceNets(iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)\nNaiveSurfaceNets(;iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)\nNaiveSurfaceNets(iso)\nNaiveSurfaceNets(iso,eps)\n\nSpecifies the use of the Naive Surface Nets algorithm for isosurface extraction. This algorithm has a slight performance advantage in some cases over Marching Cubes. Each vertex is guaranteed to not be repeated (useful for topological analysis), however the algorithm does not guarantee accuracy and generates quad faces.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts reserved for future use.\ninsidepositive (default: false) set true if the sign convention inside the surface is positive, common for NRRD and DICOM data\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.AbstractMeshingAlgorithm","page":"API","title":"Meshing.AbstractMeshingAlgorithm","text":"AbstractMeshingAlgorithm\n\nAbstract type to specify an algorithm for isosurface extraction. See:\n\nMarchingCubes\nMarchingTetrahedra\nNaiveSurfaceNets\n\n\n\n\n\n","category":"type"},{"location":"api/#Isosurface-1","page":"API","title":"Isosurface","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"isosurface is the common and generic API for isosurface extraction with any type of abstract vector/vertex/face type.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"isosurface","category":"page"},{"location":"api/#Meshing.isosurface","page":"API","title":"Meshing.isosurface","text":"function isosurface(sdf::AbstractArray{T, 3}, [ method::AbstractMeshingAlgorithm ],\n                     [ VertType = SVector{3,Float64} ], [ FaceType} = SVector{3, Int} ] ;\n                     origin = SVector(-1.0,-1.0,-1.0), widths = SVector(2.0,2.0,2.0))\n\nfunction isosurface(f::Function, [ method::AbstractMeshingAlgorithm ],\n                     [ VertType = SVector{3,Float64} ], [FaceType = SVector{3, Int} ] ;\n                     origin = SVector(-1.0,-1.0,-1.0), widths = SVector(2.0,2.0,2.0)\n                     samples=(24,24,24))`\n\nisosurface is the general interface to all isosurface extraction algorithms.\n\nReturns: (Vector{VertType}, Vector{FaceType})\n\nDefaults:\n\nVertType = SVector{3,Float64} (positional)\nFaceType = SVector{3, Int} ] ; (positional)\norigin = SVector(-1.0,-1.0,-1.0) (keyword)\nwidths = SVector(2.0,2.0,2.0) (keyword)\nsamples=(24,24,24) (keyword, function sampling only)\n\nmethod must be an instance of an AbstractMeshingAlgorithm, e.g.:\n\nMarchingCubes()\nMarchingTetrahedra()\nNaiveSurfaceNets()\n\nIf isosurface is called without a specified algorithm, it will default to MarchingCubes.\n\nIf a subtype of AbstractArray is specified, the mesh will be default be centered at the origin between (-1,1) in each axis. This may be overridden by specifying a new origin and widths for the axis-aligned bounding box using keywords of the same names. For example if we want our vertices in the range of (0,1), we can specify origin=SVector(0,0,0) and widths = SVector(1,1,1).\n\nIf a function is specified, it will be uniformly sampled in each axis by the amount specified in samples. The function is called using the specifed VertType.\n\nPerformance Tips:\n\nensure VertType, origin, and widths are all of the same type\nensure the element type of VertType is the same as the specified isolevel\n\nSee also:\n\nMarchingCubes\nMarchingTetrahedra\nNaiveSurfaceNets\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryTypes-1","page":"API","title":"GeometryTypes","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Meshing extends the mesh types in GeometryTypes for convience and use with visualization tools such as Makie and MeshCat. Any instance of an AbstractMesh may be called with arguments as follows:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"    (::Type{MT})(df::SignedDistanceField{3,ST,FT}, method::AbstractMeshingAlgorithm)::MT where {MT <: AbstractMesh, ST, FT}\n    (::Type{MT})(f::Function, h::HyperRectangle, samples::NTuple{3,T}, method::AbstractMeshingAlgorithm)::MT where {MT <: AbstractMesh, T <: Integer}\n    (::Type{MT})(f::Function, h::HyperRectangle, method::AbstractMeshingAlgorithm; samples::NTuple{3,T}=_DEFAULT_SAMPLES)::MT where {MT <: AbstractMesh, T <: Integer}\n    (::Type{MT})(volume::AbstractArray{T, 3}, method::AbstractMeshingAlgorithm; vargs...) where {MT <: AbstractMesh, T}","category":"page"},{"location":"api/#","page":"API","title":"API","text":"With the GeometryTypes API, the bounding box is specified by a HyperRectangle, or keyword specified origin and widths.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Some notes on VertType and FaceType. Since it is common to simply call HomogenousMesh or GLNormalMesh, we have added promotion and default type logic to the GeometryTypes API to improve type stability and therefore performance. Both the element type of the volume, element type of the vertextype, and type of iso in the AbstractMeshingAlgorithm are all promoted. This also allows the use of auto differentiation tools on the isosurface construction.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"If for example a HomogenousMesh is requested, the default types will be Point{3,Float64} and Face{3,Int} Similarly, a GLNormalMesh specifies Point{3, Float32} and Face{3, OffsetInteger{-1,UIn32}} so these these types will be used.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"See: isosurface for the generic API.","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#NRRD-Data-1","page":"Examples","title":"NRRD Data","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The file for this example can be found here: http://www.slicer.org/slicerWiki/images/0/00/CTA-cardio.nrrd","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"\nusing FileIO\nusing NRRD\nusing Meshing\nusing MeshIO\nusing GeometryTypes\n\n# load the file as an AxisArray\nctacardio = load(\"CTA-cardio.nrrd\")\n\n# use marching cubes with isolevel at 100\nalgo = MarchingCubes(iso=100, insidepositive=true)\n# use marching tetrahedra with iso at 100\n# algo = MarchingTetrahedra(iso=100, insidepositive=true)\n# use Naive Surface Nets with iso at 100\n# algo = NaiveSurfaceNets(iso=100, insidepositive=true)\n\n# generate the mesh using marching cubes\nmc = HomogenousMesh{Point{3,Float32},Face{3,Int}}(ctacardio, algo)\n\n# we can call isosurface to get a vector of points and vector of faces indexing to the points\n# vertices, faces = isosurface(ctacardio, also, Point{3,Float32}, Face{3,Int})\n\n# save the file as a PLY file (change extension to save as STL, OBJ, OFF)\nsave(\"ctacardio_mc.ply\", mc)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"(Image: cta cardio)","category":"page"},{"location":"#Meshing.jl-1","page":"Index","title":"Meshing.jl","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"This package provides a suite of meshing (isosurface extraction) algorithms.","category":"page"},{"location":"#","page":"Index","title":"Index","text":"Algorithms included:","category":"page"},{"location":"#","page":"Index","title":"Index","text":"Marching Tetrahedra\nMarching Cubes\nNaive Surface Nets","category":"page"},{"location":"#What-is-isosurface-extraction?-1","page":"Index","title":"What is isosurface extraction?","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"Isosurface extraction is a common technique to visualize and analyze scalar fields and functions. It takes scalar data that is structured in grids and converts this into a series of points and faces suitable for 3D visualization, GPU computing, 3D Printing, or other analyses.","category":"page"},{"location":"#","page":"Index","title":"Index","text":"There are several applications for these techniques such as:","category":"page"},{"location":"#","page":"Index","title":"Index","text":"Medical Imaging of CT and MRI data\nVisualization of Functions\nSolid Modeling\nTerrain Generation","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The internals of Meshing have been optimized for performance and to be generic. This is some brief documentation on the basic internal functions.","category":"page"},{"location":"internals/#Common-1","page":"Internals","title":"Common","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Meshing._DEFAULT_SAMPLES\nMeshing._get_cubeindex\nMeshing._get_cubeindex_pos\nMeshing._determine_types","category":"page"},{"location":"internals/#Meshing._DEFAULT_SAMPLES","page":"Internals","title":"Meshing._DEFAULT_SAMPLES","text":"_DEFAULT_SAMPLES = (24,24,24)\n\nGlobal default sampling count for functions.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#Meshing._get_cubeindex","page":"Internals","title":"Meshing._get_cubeindex","text":"_get_cubeindex(iso_vals, iso)\n\ngiven iso_vals and iso, return an 8 bit value corresponding to each corner of a cube. In each bit position, 0 indicates in the isosurface and 1 indicates outside the surface, where the sign convention indicates negative inside the surface\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing._get_cubeindex_pos","page":"Internals","title":"Meshing._get_cubeindex_pos","text":"_get_cubeindex_pos(iso_vals, iso)\n\ngiven iso_vals and iso, return an 8 bit value corresponding to each corner of a cube. In each bit position, 0 indicates in the isosurface and 1 indicates outside the surface, where the sign convention indicates positive inside the surface\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing._determine_types","page":"Internals","title":"Meshing._determine_types","text":"_determine_types(meshtype, fieldtype=Float64, facelen=3)\n\nGiven a subtype of AbstractMesh, determine the type of vertex/point and face to use for internal computations.\n\nPreference is given to the types specified by the Mesh call, and will default to the FieldType for SignedDistanceField, and Point{3,Float64}/Face{3,Int} for direct function sampling.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Marching-Cubes-1","page":"Internals","title":"Marching Cubes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Meshing._mc_create_triangles!\nMeshing._mc_unique_triangles!\nMeshing.find_vertices_interp\nMeshing.vertex_interp\nMeshing.mc_vert_points","category":"page"},{"location":"internals/#Meshing._mc_create_triangles!","page":"Internals","title":"Meshing._mc_create_triangles!","text":"_mc_create_triangles!(vts, fcs, vertlist, cubeindex, FaceType)\n\nCreate triangles by adding every point within a triangle to the vertex vector.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing._mc_unique_triangles!","page":"Internals","title":"Meshing._mc_unique_triangles!","text":"_mc_unique_triangles!(vts, fcs, vertlist, cubeindex, FaceType)\n\nCreate triangles by only adding unique vertices within the voxel. Each face may share a reference to a vertex with another face.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.find_vertices_interp","page":"Internals","title":"Meshing.find_vertices_interp","text":"find_vertices_interp(points, iso_vals, cubeindex, iso, eps)\n\nFind the vertices where the surface intersects the cube\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.vertex_interp","page":"Internals","title":"Meshing.vertex_interp","text":"vertex_interp(iso, p1, p2, valp1, valp2, eps = 0.00001)\n\nLinearly interpolate the position where an isosurface cuts an edge between two vertices, each with their own scalar value\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.mc_vert_points","page":"Internals","title":"Meshing.mc_vert_points","text":"mc_vert_points(xi,yi,zi, scale, origin, ::Type{VertType})\n\nReturns a tuple of 8 points corresponding to each corner of a cube\n\n\n\n\n\n","category":"function"},{"location":"internals/#Marching-Tetrahedra-1","page":"Internals","title":"Marching Tetrahedra","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Voxel corner and edge indexing conventions\n\n        Z\n        |\n\n        5------5------6              Extra edges not drawn\n       /|            /|              -----------\n      8 |           6 |              - face diagonals\n     /  9          /  10                - 13: 1 to 3\n    8------7------7   |                 - 14: 1 to 8\n    |   |         |   |                 - 15: 1 to 6\n    |   1------1--|---2  -- Y           - 16: 5 to 7\n    12 /          11 /                  - 17: 2 to 7\n    | 4           | 2                   - 18: 4 to 7\n    |/            |/                 - body diagonal\n    4------3------3                     - 19: 1 to 7\n\n  /\n X","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Meshing._correct_vertices!\nMeshing.procVox\nMeshing.voxEdgeId\nMeshing.getVertId\nMeshing.vertPos\nMeshing.vertId\nMeshing.tetIx","category":"page"},{"location":"internals/#Meshing.procVox","page":"Internals","title":"Meshing.procVox","text":"procVox(vals, iso::Real, x, y, z, nx, ny,\n                vts::Dict, vtsAry::Vector, fcs::Vector,\n                eps::Real)\n\nProcesses a voxel, adding any new vertices and faces to the given containers as necessary.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.voxEdgeId","page":"Internals","title":"Meshing.voxEdgeId","text":"voxEdgeId(subTetIx, tetEdgeIx)\n\nGiven a sub-tetrahedron case and a tetrahedron edge ID, determines the corresponding voxel edge ID.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.getVertId","page":"Internals","title":"Meshing.getVertId","text":"getVertId(e, x, y, z, nx, ny,\n            vals, iso::Real,\n            vts::Dict,\n            vtsAry::Vector,\n            eps::Real)\n\nGets the vertex ID, adding it to the vertex dictionary if not already present.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.vertPos","page":"Internals","title":"Meshing.vertPos","text":"vertPos(e, x, y, z, vals::NTuple{8,T}, iso::Real, eps::Real, ::Type{VertType}) where {T<:Real, VertType}\n\nAssuming an edge crossing, determines the point in space at which it occurs. eps represents the \"bump\" factor to keep vertices away from voxel corners (thereby preventing degeneracies).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.vertId","page":"Internals","title":"Meshing.vertId","text":"vertId(e, x, y, z, nx, ny)\n\nDetermines a unique integer ID associated with the edge. This is used as a key in the vertex dictionary. It needs to be both unambiguous (no two edges get the same index) and unique (every edge gets the same ID regardless of which of its neighboring voxels is asking for it) in order for vertex sharing to be implemented properly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.tetIx","page":"Internals","title":"Meshing.tetIx","text":"tetIx(tIx, cubeindex)\n\nDetermines which case in the triangle table we are dealing with\n\n\n\n\n\n","category":"function"},{"location":"internals/#Surface-Nets-1","page":"Internals","title":"Surface Nets","text":"","category":"section"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Meshing</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Meshing</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Quick-Start-1">Quick Start</a></li><li><a class="toctext" href="#Meshing-Algorithms-1">Meshing Algorithms</a></li><li><a class="toctext" href="#Isosurface-1">Isosurface</a></li><li><a class="toctext" href="#GeometryTypes-1">GeometryTypes</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/JuliaGeometry/Meshing.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Quick-Start-1" href="#Quick-Start-1">Quick Start</a></h2><p>The easiest way to work with Meshing is with GeometryTypes. This package extends the <a href="http://juliageometry.github.io/GeometryTypes.jl/latest/types.html#Meshes-1">mesh constructors</a> from <a href="https://github.com/JuliaGeometry/GeometryTypes.jl">GeometryTypes.jl</a> for convience.</p><p>The algorithms operate on a <code>Function</code>, <code>AbstractArray</code>, or <code>SignedDistanceField</code> and output a concrete <code>AbstractMesh</code>. For example:</p><pre><code class="language-none">using Meshing
using GeometryTypes
using LinearAlgebra: dot, norm
using FileIO

# Mesh an equation of sphere in the Axis-Aligned Bounding box starting
# at -1,-1,-1 and widths of 2,2,2 using Marching Cubes
m = GLNormalMesh(HyperRectangle(Vec(-1,-1,-1.), Vec(2,2,2.)), MarchingCubes()) do v
    sqrt(sum(dot(v,v))) - 1
end

# save the Sphere as a PLY file
save(&quot;sphere.ply&quot;,m)</code></pre><p>For a full listing of concrete <code>AbstractMesh</code> types see <a href="http://juliageometry.github.io/GeometryTypes.jl/latest/types.html#Meshes-1">GeometryTypes.jl mesh documentation</a>.</p><h2><a class="nav-anchor" id="Meshing-Algorithms-1" href="#Meshing-Algorithms-1">Meshing Algorithms</a></h2><p>Three meshing algorithms exist:</p><ul><li><code>MarchingCubes()</code></li><li><code>MarchingTetrahedra()</code></li><li><code>NaiveSurfaceNets()</code></li></ul><p>Each takes an optional <code>iso</code> and <code>eps</code> parameter, e.g. <code>MarchingCubes(0.0,1e-6)</code>.</p><p>Here <code>iso</code> controls the offset for the boundary detection. By default this is set to 0. <code>eps</code> is the detection tolerance for a voxel edge intersection.</p><p>Users must construct an algorithm type and use it as an argument to a GeometryTypes mesh call or <code>isosurface</code> call.</p><p>Below is a comparison of the algorithms:</p><table><tr><th style="text-align: right">Algorithm Type</th><th style="text-align: right">Face Type</th><th style="text-align: right">Unique Vertices</th><th style="text-align: right">Performance</th><th style="text-align: right">Interpolation</th></tr><tr><td style="text-align: right">Naive Surface Nets</td><td style="text-align: right">Quad</td><td style="text-align: right">Yes</td><td style="text-align: right">~1x</td><td style="text-align: right">Voxel Edge Weight</td></tr><tr><td style="text-align: right">Marching Cubes</td><td style="text-align: right">Triangle</td><td style="text-align: right">No/Partial</td><td style="text-align: right">1x</td><td style="text-align: right">Linear on Edge</td></tr><tr><td style="text-align: right">Marching Tetrahedra</td><td style="text-align: right">Triangle</td><td style="text-align: right">Yes</td><td style="text-align: right">3x</td><td style="text-align: right">Linear on Edge</td></tr></table><p>Visual Comparison: From left: Marching Cubes, Naive Surface Nets, Marching Tetrahedra</p><p><img src="../img/comparison.png" alt="comparison"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.MarchingCubes" href="#Meshing.MarchingCubes"><code>Meshing.MarchingCubes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MarchingCubes(iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)
MarchingCubes(;iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)
MarchingCubes(iso)
MarchingCubes(iso,eps)</code></pre><p>Specifies the use of the Marching Cubes algorithm for isosurface extraction. This algorithm provides a good balance between performance and vertex count. In contrast to the other algorithms, vertices may be repeated, so mesh size may be large and it will be difficult to extract topological/connectivity information.</p><ul><li><code>iso</code> (default: 0.0) specifies the iso level to use for surface extraction.</li><li><code>eps</code> (default: 1e-3) is the tolerence around a voxel corner to ensure manifold mesh generation.</li><li><code>reduceverts</code> (default: true) if true will merge vertices within a voxel to reduce mesh size by around 30% and with slight performance improvement.</li><li><code>insidepositive</code> (default: false) set true if the sign convention inside the surface is positive, common for NRRD and DICOM data</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGeometry/Meshing.jl/blob/99abc97e81d3b4f7806ce26ba3ef9245daa6f324/src/algorithmtypes.jl#L13-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.MarchingTetrahedra" href="#Meshing.MarchingTetrahedra"><code>Meshing.MarchingTetrahedra</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MarchingTetrahedra(iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)
MarchingTetrahedra(;iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)
MarchingTetrahedra(iso)
MarchingTetrahedra(iso,eps)</code></pre><p>Specifies the use of the Marching Tetrahedra algorithm for isosurface extraction. This algorithm has a roughly 2x performance penalty compared to Marching Cubes, and generates more faces. However, each vertex is guaranteed to not be repeated, making this algorithm useful for topological analysis.</p><ul><li><code>iso</code> specifies the iso level to use for surface extraction.</li><li><code>eps</code> is the tolerence around a voxel corner to ensure manifold mesh generation.</li><li><code>reduceverts</code> reserved for future use.</li><li><code>insidepositive</code> reserved for future use.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGeometry/Meshing.jl/blob/99abc97e81d3b4f7806ce26ba3ef9245daa6f324/src/algorithmtypes.jl#L41-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.NaiveSurfaceNets" href="#Meshing.NaiveSurfaceNets"><code>Meshing.NaiveSurfaceNets</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NaiveSurfaceNets(iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)
NaiveSurfaceNets(;iso=0.0, eps=1e-3, reduceverts=true, insidepositive=false)
NaiveSurfaceNets(iso)
NaiveSurfaceNets(iso,eps)</code></pre><p>Specifies the use of the Naive Surface Nets algorithm for isosurface extraction. This algorithm has a slight performance advantage in some cases over Marching Cubes. Each vertex is guaranteed to not be repeated (useful for topological analysis), however the algorithm does not guarantee accuracy and generates quad faces.</p><ul><li><code>iso</code> specifies the iso level to use for surface extraction.</li><li><code>eps</code> is the tolerence around a voxel corner to ensure manifold mesh generation.</li><li><code>reduceverts</code> reserved for future use.</li><li><code>insidepositive</code> reserved for future use.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGeometry/Meshing.jl/blob/99abc97e81d3b4f7806ce26ba3ef9245daa6f324/src/algorithmtypes.jl#L68-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.AbstractMeshingAlgorithm" href="#Meshing.AbstractMeshingAlgorithm"><code>Meshing.AbstractMeshingAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMeshingAlgorithm</code></pre><p>Abstract type to specify an algorithm for isosurface extraction. See:</p><ul><li>MarchingCubes</li><li>MarchingTetrahedra</li><li>NaiveSurfaceNets</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGeometry/Meshing.jl/blob/99abc97e81d3b4f7806ce26ba3ef9245daa6f324/src/algorithmtypes.jl#L2-L10">source</a></section><h2><a class="nav-anchor" id="Isosurface-1" href="#Isosurface-1">Isosurface</a></h2><p><code>isosurface</code> is the common and generic API for isosurface extraction with any type of abstract vector/vertex/face type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.isosurface" href="#Meshing.isosurface"><code>Meshing.isosurface</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function isosurface(sdf::AbstractArray{T, 3}, method::AbstractMeshingAlgorithm,
                     [ VertType = SVector{3,Float64} ], [ FaceType} = SVector{3, Int} ] ;
                     origin = SVector(-1.0,-1.0,-1.0), widths = SVector(2.0,2.0,2.0))

function isosurface(f::Function, method::AbstractMeshingAlgorithm,
                     [ VertType = SVector{3,Float64} ], [FaceType = SVector{3, Int} ] ;
                     origin = SVector(-1.0,-1.0,-1.0), widths = SVector(2.0,2.0,2.0)
                     samples=(24,24,24))`</code></pre><p><code>isosurface</code> is the general interface to all isosurface extraction algorithms.</p><p>Returns: (Vector{VertType}, Vector{FaceType})</p><p>Defaults:</p><ul><li>VertType = SVector{3,Float64}</li><li>FaceType = SVector{3, Int} ] ;</li><li>origin = SVector(-1.0,-1.0,-1.0)</li><li>widths = SVector(2.0,2.0,2.0)</li><li>samples=(24,24,24) (function sampling only)</li></ul><p><code>method</code> must be an instance of an <code>AbstractMeshingAlgorithm</code></p><p>If a subtype of <code>AbstractArray</code> is specified, the mesh will be default be centered at the origin between (-1,1) in each axis. This may be overridden by specifying a new origin and widths for the axis-aligned bounding box using keywords of the same names. For example if we want our vertices in the range of (0,1), we can specify <code>origin=SVector(0,0,0)</code> and <code>widths = SVector(1,1,1)</code>.</p><p>If a function is specified, it will be uniformly sampled in each axis by the amount specified in <code>samples</code>. The function is called the a single argument of <code>VertType</code>.</p><p>Performance Tips:</p><ul><li>ensure <code>VertType</code>, <code>origin</code>, and <code>widths</code> are all of the same type</li><li>ensure the element type of <code>VertType</code> is the same as the specified isolevel</li></ul><p>See also:</p><ul><li>MarchingCubes</li><li>MarchingTetrahedra</li><li>NaiveSurfaceNets</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGeometry/Meshing.jl/blob/99abc97e81d3b4f7806ce26ba3ef9245daa6f324/src/common.jl#L73-L114">source</a></section><h2><a class="nav-anchor" id="GeometryTypes-1" href="#GeometryTypes-1">GeometryTypes</a></h2><p>Meshing extends the mesh types in GeometryTypes for convience and use with visualization tools such as Makie and MeshCat. Any instance of an <code>AbstractMesh</code> may be called with arguements as follows:</p><pre><code class="language-none">    (::Type{MT})(df::SignedDistanceField{3,ST,FT}, method::AbstractMeshingAlgorithm)::MT where {MT &lt;: AbstractMesh, ST, FT}
    (::Type{MT})(f::Function, h::HyperRectangle, samples::NTuple{3,T}, method::AbstractMeshingAlgorithm)::MT where {MT &lt;: AbstractMesh, T &lt;: Integer}
    (::Type{MT})(f::Function, h::HyperRectangle, method::AbstractMeshingAlgorithm; samples::NTuple{3,T}=_DEFAULT_SAMPLES)::MT where {MT &lt;: AbstractMesh, T &lt;: Integer}
    (::Type{MT})(volume::AbstractArray{T, 3}, method::AbstractMeshingAlgorithm; vargs...) where {MT &lt;: AbstractMesh, T}</code></pre><p>With the GeometryTypes API, the bounding box is specified by a <code>HyperRectangle</code>.</p><p>Some notes on VertType and FaceType. Since it is common to simply call <code>HomogenousMesh</code> or <code>GLNormalMesh</code>, we have added promotion and default type logic to the GeometryTypes API to improve type stability and therefore performance. Both the element type of the volume, element type of the <code>vertextype</code>, and type of <code>iso</code> in the <code>AbstractMeshingAlgorithm</code> are all promoted. This also allows the use of auto differentiation tools on the isosurface construction.</p><p>If for example a <code>HomogenousMesh</code> is requested, the default types will be <code>Point{3,Float64}</code> and <code>Face{3,Int}</code> Similarly, a <code>GLNormalMesh</code> specifies <code>Point{3, Float32}</code> and <code>Face{3, OffsetInteger{-1,UIn32}}</code> so these these types will be used.</p><p>See: <code>isosurface</code> for the generic API.</p><footer><hr/><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>

var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Quick-Start-isosurface","page":"API","title":"Quick Start - isosurface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Given 3D levelset data such as a CT scan, we can do:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Meshing\n\nA = rand(50,50,50) # 3D Matrix\n\npoints,faces = isosurface(A)","category":"page"},{"location":"api/","page":"API","title":"API","text":"An iso-level is specified within the algorithm specification as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Meshing\n\nA = rand(50,50,50) # 3D Matrix\n\npoints,faces = isosurface(A, MarchingCubes(iso=1))","category":"page"},{"location":"api/#Isosurface","page":"API","title":"Isosurface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"isosurface is the common and generic API for isosurface extraction with any type of abstract vector/vertex/face type.","category":"page"},{"location":"api/","page":"API","title":"API","text":"isosurface","category":"page"},{"location":"api/#Meshing.isosurface","page":"API","title":"Meshing.isosurface","text":"isosurface(V)\nisosurface(V, method::AbstractMeshingAlgorithm, X, Y, Z)\n\nisosurface is the general interface to all isosurface extraction algorithms.\n\nReturns: (Vector{NTuple{3, T}, }, Vector{NTuple{3, Int}})\n\nDefaults: method must be an instance of an AbstractMeshingAlgorithm, e.g.:\n\nMarchingCubes()\nMarchingTetrahedra()\n\nIf isosurface is called without a specified algorithm, it will default to MarchingCubes.\n\nIf a subtype of AbstractArray is specified, the mesh will by default be centered at the origin between (-1,1) in each axis.\n\nSee also:\n\nMarchingCubes\nMarchingTetrahedra\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshing-Algorithms","page":"API","title":"Meshing Algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Three meshing algorithms exist:","category":"page"},{"location":"api/","page":"API","title":"API","text":"MarchingCubes()\nMarchingTetrahedra()","category":"page"},{"location":"api/","page":"API","title":"API","text":"Each takes optional iso and eps parameters, e.g. MarchingCubes(iso=0.0,eps=1e-6).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Here iso controls the offset for the boundary detection. By default this is set to 0. eps is the detection tolerance for a voxel edge intersection.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Users must construct an algorithm type and use it as an argument to a GeometryTypes mesh call or isosurface call.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Visual Comparison: From left: Marching Cubes, Naive Surface Nets, Marching Tetrahedra","category":"page"},{"location":"api/","page":"API","title":"API","text":"(Image: comparison)","category":"page"},{"location":"api/","page":"API","title":"API","text":"MarchingCubes\nMarchingTetrahedra\nMeshing.AbstractMeshingAlgorithm","category":"page"},{"location":"api/#Meshing.MarchingCubes","page":"API","title":"Meshing.MarchingCubes","text":"MarchingCubes(;iso=0.0)\n\nSpecifies the use of the Marching Cubes algorithm for isosurface extraction. This algorithm provides a good balance between performance and vertex count. In contrast to the other algorithms, vertices may be repeated, so mesh size may be large and it will be difficult to extract topological/connectivity information.\n\niso (default: 0.0) specifies the iso level to use for surface extraction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.MarchingTetrahedra","page":"API","title":"Meshing.MarchingTetrahedra","text":"MarchingTetrahedra(;iso=0.0, eps=1e-3)\n\nSpecifies the use of the Marching Tetrahedra algorithm for isosurface extraction. This algorithm generates more faces. However, each vertex is guaranteed to not be repeated, making this algorithm useful for topological analysis.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.AbstractMeshingAlgorithm","page":"API","title":"Meshing.AbstractMeshingAlgorithm","text":"AbstractMeshingAlgorithm\n\nAbstract type to specify an algorithm for isosurface extraction. See:\n\nMarchingCubes\nMarchingTetrahedra\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#NRRD-Data","page":"Examples","title":"NRRD Data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The file for this example can be found here: http://www.slicer.org/slicerWiki/images/0/00/CTA-cardio.nrrd","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Meshing\nusing FileIO\nusing NRRD\nusing WGLMakie\nusing Downloads\nusing GeometryBasics\n\nnrrd = Downloads.download(\"http://www.slicer.org/slicerWiki/images/0/00/CTA-cardio.nrrd\")\n\n# load the file as an AxisArray\nctacardio = load(nrrd)\n\n# use marching cubes with isolevel at 100\n#algo = MarchingCubes(iso=100)\n# use marching tetrahedra with iso at 100\n algo = MarchingTetrahedra(iso=100)\n\n\n# generate the mesh using marching cubes\nvts, fcs = isosurface(ctacardio, algo)\n\nWGLMakie.mesh(vts, map(v -> GeometryBasics.TriangleFace(v...), fcs))\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: cta cardio)","category":"page"},{"location":"examples/#Gyroid-and-Isocaps","page":"Examples","title":"Gyroid and Isocaps","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We do not provide an equivalent to isocaps in Matlab, though a similar result may be achieved by setting the boundary to a large value:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GeometryTypes\n\ngyroid(v) = cos(v[1])*sin(v[2])+cos(v[2])*sin(v[3])+cos(v[3])*sin(v[1])\ngyroid_shell(v) = max(gyroid(v)-0.4,-gyroid(v)-0.4)\n\nxr,yr,zr = ntuple(_->LinRange(0,pi*4,50),3)\n\nA = [gyroid_shell((x,y,z)) for x in xr, y in yr, z in zr]\nA[1,:,:] .= 1e10\nA[:,1,:] .= 1e10\nA[:,:,1] .= 1e10\nA[end,:,:] .= 1e10\nA[:,end,:] .= 1e10\nA[:,:,end] .= 1e10\n\nvts, fcs = isosurface(A, MarchingCubes())\n\n# view with Makie\nimport WGLMakie\nusing LinearAlgebra\nWGLMakie.mesh(vts, map(v -> GeometryBasics.TriangleFace(v...), fcs), color=[norm(v) for v in v])","category":"page"},{"location":"#Meshing.jl","page":"Index","title":"Meshing.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This package provides a suite of meshing (isosurface extraction) algorithms.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Algorithms included:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Marching Tetrahedra\nMarching Cubes","category":"page"},{"location":"#What-is-isosurface-extraction?","page":"Index","title":"What is isosurface extraction?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Isosurface extraction is a common technique to visualize and analyze scalar fields and functions. It takes scalar data that is structured in grids and converts this into a series of points and faces suitable for 3D visualization, GPU computing, 3D Printing, or other analyses.","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are several applications for these techniques such as:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Medical Imaging of CT and MRI data\nVisualization of Functions\nSolid Modeling\nTerrain Generation","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Quick-Start-1","page":"API","title":"Quick Start","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"This package inherits the mesh types from GeometryTypes.jl.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The algorithms operate on a Function or a SignedDistanceField and output a concrete AbstractMesh. For example:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using Meshing\nusing GeometryTypes\nusing LinearAlgebra: dot, norm\nusing FileIO\n\n# Mesh an equation of sphere in the Axis-Aligned Bounding box starting\n# at -1,-1,-1 and widths of 2,2,2\nm = GLNormalMesh(HyperRectangle(Vec(-1,-1,-1.), Vec(2,2,2.)), MarchingCubes()) do v\n    sqrt(sum(dot(v,v))) - 1\nend\n\n# save the Sphere as a PLY file\nsave(\"sphere.ply\",m)","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The general API is: (::Type{MT})(sdf::Function, method::AbstractMeshingAlgorithm) where {MT <: AbstractMesh} or (::Type{MT})(sdf::SignedDistanceField, method::AbstractMeshingAlgorithm) where {MT <: AbstractMesh}","category":"page"},{"location":"api/#","page":"API","title":"API","text":"For a full listing of concrete AbstractMesh types see GeometryTypes.jl mesh documentation.","category":"page"},{"location":"api/#Meshing-Algorithms-1","page":"API","title":"Meshing Algorithms","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Three meshing algorithms exist:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"MarchingCubes()\nMarchingTetrahedra()\nNaiveSurfaceNets()","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Each takes an optional iso and eps parameter, e.g. MarchingCubes(0.0,1e-6).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Here iso controls the offset for the boundary detection. By default this is set to 0. eps is the detection tolerance for a voxel edge intersection.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Below is a comparison of the algorithms:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Algorithm Accurate Manifold Performance Penalty Face Type\nMarchingCubes Yes No ~2x Triangle\nMarchingTetrahedra Yes Yes ~3x Triangle\nNaiveSurfaceNets No Yes 1x Quad","category":"page"},{"location":"api/#","page":"API","title":"API","text":"MarchingCubes\nMarchingTetrahedra\nNaiveSurfaceNets","category":"page"},{"location":"api/#Meshing.MarchingCubes","page":"API","title":"Meshing.MarchingCubes","text":"MarchingCubes(iso=0.0, eps=1e-3, reduceverts=true)\nMarchingCubes(;iso=0.0, eps=1e-3, reduceverts=true)\nMarchingCubes(iso)\nMarchingCubes(iso,eps)\n\nSpecifies the use of the Marching Cubes algorithm for isosurface extraction. This algorithm provides a good balance between performance and vertex count. In contrast to the other algorithms, vertices may be repeated, so face counts may be large.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts if true will merge vertices within a voxel to reduce mesh size by around 30% and with no performance penalty.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.MarchingTetrahedra","page":"API","title":"Meshing.MarchingTetrahedra","text":"MarchingTetrahedra(iso=0.0, eps=1e-3, reduceverts=true)\nMarchingTetrahedra(;iso=0.0, eps=1e-3, reduceverts=true)\nMarchingTetrahedra(iso)\nMarchingTetrahedra(iso,eps)\n\nSpecifies the use of the Marching Tetrahedra algorithm for isosurface extraction. This algorithm has a roughly 2x performance penalty compared to Marching Cubes, and generates more faces. However, each vertex is guaranteed to not be repeated, making this algorithm useful for topological analysis.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts reserved for future use.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.NaiveSurfaceNets","page":"API","title":"Meshing.NaiveSurfaceNets","text":"NaiveSurfaceNets(iso=0.0, eps=1e-3, reduceverts=true)\nNaiveSurfaceNets(;iso=0.0, eps=1e-3, reduceverts=true)\nNaiveSurfaceNets(iso)\nNaiveSurfaceNets(iso,eps)\n\nSpecifies the use of the Naive Surface Nets algorithm for isosurface extraction. This algorithm has a slight performance advantage in some cases over Marching Cubes. Each vertex is guaranteed to not be repeated, however the algorithm does not guarantee accuracy and generates quad faces.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts reserved for future use.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#NRRD-Data-1","page":"Examples","title":"NRRD Data","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The file for this example can be found here: http://www.slicer.org/slicerWiki/images/0/00/CTA-cardio.nrrd","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"\nusing FileIO\nusing NRRD\nusing Meshing\nusing MeshIO\nusing GeometryTypes\n\nhere = dirname(@__FILE__)\n\n# load the file as an AxisArray\nctacardio = load(here*\"/../data/CTA-cardio.nrrd\")\nq = -100 # isolevel\n\n\n# flip sign on nrrd data since we need inside to be negative\n# TODO\nfor i in eachindex(ctacardio.data)\n    ctacardio.data[i] = -ctacardio.data[i]\nend\n\n# convert AxisArray to SignedDistanceField\nctasdf = SignedDistanceField(HyperRectangle(Vec(0,0,0), Vec(10,10,10)),ctacardio.data)\n\n# generate the mesh using marching cubes\nmc = HomogenousMesh{Point{3,Float32},Face{3,Int}}(ctasdf, MarchingCubes(q))\n\n# save the file as a PLY file\nsave(\"ctacardio_mc.ply\", mc)","category":"page"},{"location":"#Meshing.jl-1","page":"Meshing.jl","title":"Meshing.jl","text":"","category":"section"},{"location":"#","page":"Meshing.jl","title":"Meshing.jl","text":"This package provides a comprehensive suite of meshing (isosurface extraction) algorithms.","category":"page"},{"location":"#","page":"Meshing.jl","title":"Meshing.jl","text":"Algorithms included:","category":"page"},{"location":"#","page":"Meshing.jl","title":"Meshing.jl","text":"Marching Tetrahedra\nMarching Cubes\nNaive Surface Nets","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Marching-Cubes-1","page":"Internals","title":"Marching Cubes","text":"","category":"section"},{"location":"internals/#Marching-Tetrahedra-1","page":"Internals","title":"Marching Tetrahedra","text":"","category":"section"},{"location":"internals/#Surface-Nets-1","page":"Internals","title":"Surface Nets","text":"","category":"section"}]
}

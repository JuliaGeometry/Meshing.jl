var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Quick-Start-1","page":"API","title":"Quick Start","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"This package inherits the mesh types from GeometryTypes.jl.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The algorithms operate on a Function or a SignedDistanceField and output a concrete AbstractMesh. For example:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using Meshing\nusing GeometryTypes\nusing LinearAlgebra: dot, norm\nusing FileIO\n\n# Mesh an equation of sphere in the Axis-Aligned Bounding box starting\n# at -1,-1,-1 and widths of 2,2,2\nm = GLNormalMesh(HyperRectangle(Vec(-1,-1,-1.), Vec(2,2,2.)), MarchingCubes()) do v\n    sqrt(sum(dot(v,v))) - 1\nend\n\n# save the Sphere as a PLY file\nsave(\"sphere.ply\",m)","category":"page"},{"location":"api/#","page":"API","title":"API","text":"The general API is: (::Type{MT})(sdf::Function, method::AbstractMeshingAlgorithm) where {MT <: AbstractMesh} or (::Type{MT})(sdf::SignedDistanceField, method::AbstractMeshingAlgorithm) where {MT <: AbstractMesh}","category":"page"},{"location":"api/#","page":"API","title":"API","text":"For a full listing of concrete AbstractMesh types see GeometryTypes.jl mesh documentation.","category":"page"},{"location":"api/#Meshing-Algorithms-1","page":"API","title":"Meshing Algorithms","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Three meshing algorithms exist:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"MarchingCubes()\nMarchingTetrahedra()\nNaiveSurfaceNets()","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Each takes an optional iso and eps parameter, e.g. MarchingCubes(0.0,1e-6).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Here iso controls the offset for the boundary detection. By default this is set to 0. eps is the detection tolerance for a voxel edge intersection.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Below is a comparison of the algorithms:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Algorithm Accurate Manifold Performance Penalty Face Type\nMarchingCubes Yes No ~2x Triangle\nMarchingTetrahedra Yes Yes ~3x Triangle\nNaiveSurfaceNets No Yes 1x Quad","category":"page"},{"location":"api/#","page":"API","title":"API","text":"MarchingCubes\nMarchingTetrahedra\nNaiveSurfaceNets","category":"page"},{"location":"api/#Meshing.MarchingCubes","page":"API","title":"Meshing.MarchingCubes","text":"MarchingCubes(iso=0.0, eps=1e-3, reduceverts=true)\nMarchingCubes(;iso=0.0, eps=1e-3, reduceverts=true)\nMarchingCubes(iso)\nMarchingCubes(iso,eps)\n\nSpecifies the use of the Marching Cubes algorithm for isosurface extraction. This algorithm provides a good balance between performance and vertex count. In contrast to the other algorithms, vertices may be repeated, so face counts may be large.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts if true will merge vertices within a voxel to reduce mesh size by around 30% and with no performance penalty.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.MarchingTetrahedra","page":"API","title":"Meshing.MarchingTetrahedra","text":"MarchingTetrahedra(iso=0.0, eps=1e-3, reduceverts=true)\nMarchingTetrahedra(;iso=0.0, eps=1e-3, reduceverts=true)\nMarchingTetrahedra(iso)\nMarchingTetrahedra(iso,eps)\n\nSpecifies the use of the Marching Tetrahedra algorithm for isosurface extraction. This algorithm has a roughly 2x performance penalty compared to Marching Cubes, and generates more faces. However, each vertex is guaranteed to not be repeated, making this algorithm useful for topological analysis.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts reserved for future use.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshing.NaiveSurfaceNets","page":"API","title":"Meshing.NaiveSurfaceNets","text":"NaiveSurfaceNets(iso=0.0, eps=1e-3, reduceverts=true)\nNaiveSurfaceNets(;iso=0.0, eps=1e-3, reduceverts=true)\nNaiveSurfaceNets(iso)\nNaiveSurfaceNets(iso,eps)\n\nSpecifies the use of the Naive Surface Nets algorithm for isosurface extraction. This algorithm has a slight performance advantage in some cases over Marching Cubes. Each vertex is guaranteed to not be repeated, however the algorithm does not guarantee accuracy and generates quad faces.\n\niso specifies the iso level to use for surface extraction.\neps is the tolerence around a voxel corner to ensure manifold mesh generation.\nreduceverts reserved for future use.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#NRRD-Data-1","page":"Examples","title":"NRRD Data","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The file for this example can be found here: http://www.slicer.org/slicerWiki/images/0/00/CTA-cardio.nrrd","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"\nusing FileIO\nusing NRRD\nusing Meshing\nusing MeshIO\nusing GeometryTypes\n\nhere = dirname(@__FILE__)\n\n# load the file as an AxisArray\nctacardio = load(here*\"/../data/CTA-cardio.nrrd\")\nq = -100 # isolevel\n\n\n# flip sign on nrrd data since we need inside to be negative\n# TODO\nfor i in eachindex(ctacardio.data)\n    ctacardio.data[i] = -ctacardio.data[i]\nend\n\n# convert AxisArray to SignedDistanceField\nctasdf = SignedDistanceField(HyperRectangle(Vec(0,0,0), Vec(10,10,10)),ctacardio.data)\n\n# generate the mesh using marching cubes\nmc = HomogenousMesh{Point{3,Float32},Face{3,Int}}(ctasdf, MarchingCubes(q))\n\n# save the file as a PLY file\nsave(\"ctacardio_mc.ply\", mc)","category":"page"},{"location":"#Meshing.jl-1","page":"Meshing.jl","title":"Meshing.jl","text":"","category":"section"},{"location":"#","page":"Meshing.jl","title":"Meshing.jl","text":"This package provides a comprehensive suite of meshing (isosurface extraction) algorithms.","category":"page"},{"location":"#","page":"Meshing.jl","title":"Meshing.jl","text":"Algorithms included:","category":"page"},{"location":"#","page":"Meshing.jl","title":"Meshing.jl","text":"Marching Tetrahedra\nMarching Cubes\nNaive Surface Nets","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The internals of Meshing have been optimized for performance and to be generic. This is some brief documentation on the basic internal functions.","category":"page"},{"location":"internals/#Common-1","page":"Internals","title":"Common","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Meshing._get_cubeindex\nMeshing._determine_types","category":"page"},{"location":"internals/#Meshing._get_cubeindex","page":"Internals","title":"Meshing._get_cubeindex","text":"_get_cubeindex(iso_vals, iso)\n\ngiven iso_vals and iso, return an 8 bit value corresponding to each corner of a cube. In each bit position,  0 indicates in the isosurface and 1 indicates outside the surface\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing._determine_types","page":"Internals","title":"Meshing._determine_types","text":"_determine_types(meshtype, fieldtype=Float64, facelen=3)\n\nGiven a subtype of AbstractMesh, determine the type of vertex/point and face to use for internal computations.\n\nPreference is given to the types specified by the Mesh call, and will default to the FieldType for SignedDistanceField, and Point{3,Float64}/Face{3,Int} for direct function sampling.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Marching-Cubes-1","page":"Internals","title":"Marching Cubes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Meshing._mc_create_triangles!\nMeshing._mc_unique_triangles!\nMeshing.find_vertices_interp!\nMeshing.vertex_interp","category":"page"},{"location":"internals/#Meshing._mc_create_triangles!","page":"Internals","title":"Meshing._mc_create_triangles!","text":"_mc_create_triangles!(vts, fcs, vertlist, cubeindex, FaceType)\n\nCreate triangles by only adding vertices within the voxel. Each face does not share a reference to a vertex with another face.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing._mc_unique_triangles!","page":"Internals","title":"Meshing._mc_unique_triangles!","text":"_mc_unique_triangles!(vts, fcs, vertlist, cubeindex, FaceType)\n\nCreate triangles by only adding unique vertices within the voxel. Each face may share a reference to a vertex with another face.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.find_vertices_interp!","page":"Internals","title":"Meshing.find_vertices_interp!","text":"find_vertices_interp!(vertlist, points, iso_vals, cubeindex, iso, eps)\n\nFind the vertices where the surface intersects the cube\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.vertex_interp","page":"Internals","title":"Meshing.vertex_interp","text":"vertex_interp(iso, p1, p2, valp1, valp2, eps = 0.00001)\n\nLinearly interpolate the position where an isosurface cuts an edge between two vertices, each with their own scalar value\n\n\n\n\n\n","category":"function"},{"location":"internals/#Marching-Tetrahedra-1","page":"Internals","title":"Marching Tetrahedra","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Voxel corner and edge indexing conventions\n\n        Z\n        |\n\n        5------5------6              Extra edges not drawn\n       /|            /|              -----------\n      8 |           6 |              - face diagonals\n     /  9          /  10                - 13: 1 to 3\n    8------7------7   |                 - 14: 1 to 8\n    |   |         |   |                 - 15: 1 to 6\n    |   1------1--|---2  -- Y           - 16: 5 to 7\n    12 /          11 /                  - 17: 2 to 7\n    | 4           | 2                   - 18: 4 to 7\n    |/            |/                 - body diagonal\n    4------3------3                     - 19: 1 to 7\n\n  /\n X","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Meshing._correct_vertices!\nMeshing.procVox\nMeshing.voxEdgeId\nMeshing.getVertId\nMeshing.vertPos\nMeshing.vertId\nMeshing.tetIx","category":"page"},{"location":"internals/#Meshing._correct_vertices!","page":"Internals","title":"Meshing._correct_vertices!","text":"_correct_vertices!(vts, sdf::SignedDistanceField)\n\nThe marchingTetrahedra function returns vertices on the (1-based) indices of the SDF's data, ignoring its actual bounds. This function adjusts the vertices in place so that they correspond to points within the SDF bounds.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.procVox","page":"Internals","title":"Meshing.procVox","text":"procVox(vals, iso::Real, x, y, z, nx, ny,\n                vts::Dict, vtsAry::Vector, fcs::Vector,\n                eps::Real,\n                ::Type{VertType}, ::Type{FaceType}) where {VertType, FaceType}\n\nProcesses a voxel, adding any new vertices and faces to the given containers as necessary.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.voxEdgeId","page":"Internals","title":"Meshing.voxEdgeId","text":"voxEdgeId(subTetIx, tetEdgeIx)\n\nGiven a sub-tetrahedron case and a tetrahedron edge ID, determines the corresponding voxel edge ID.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.getVertId","page":"Internals","title":"Meshing.getVertId","text":"getVertId(e, x, y, z, nx, ny,\n            vals, iso::Real,\n            vts::Dict,\n            vtsAry::Vector,\n            eps::Real, ::Type{VertType}) where {VertType}\n\nGets the vertex ID, adding it to the vertex dictionary if not already present.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.vertPos","page":"Internals","title":"Meshing.vertPos","text":"vertPos(e, x, y, z, vals::NTuple{8,T}, iso::Real, eps::Real, ::Type{VertType}) where {T<:Real, VertType}\n\nAssuming an edge crossing, determines the point in space at which it occurs. eps represents the \"bump\" factor to keep vertices away from voxel corners (thereby preventing degeneracies).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.vertId","page":"Internals","title":"Meshing.vertId","text":"vertId(e, x, y, z, nx, ny)\n\nDetermines a unique integer ID associated with the edge. This is used as a key in the vertex dictionary. It needs to be both unambiguous (no two edges get the same index) and unique (every edge gets the same ID regardless of which of its neighboring voxels is asking for it) in order for vertex sharing to be implemented properly.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Meshing.tetIx","page":"Internals","title":"Meshing.tetIx","text":"tetIx(tIx, vals, iso::Real)\n\nDetermines which case in the triangle table we are dealing with\n\n\n\n\n\n","category":"function"},{"location":"internals/#Surface-Nets-1","page":"Internals","title":"Surface Nets","text":"","category":"section"}]
}
